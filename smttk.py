import os
import re
import parameters

import core

try:
    import click
except ImportError:
    pass
else:

    @click.group()
    def cli():
        pass

    @click.command()
    @click.argument('src', nargs=1)
    @click.argument('dst', nargs=1)
    @click.option('--datadir', default="")
    @click.option('--suffix', default="")
    @click.option('--ext', default=".sir")
    @click.option('--link/--no-link', default=True)
    def rename(src, dst, ext, datadir, suffix, link):
        """
        Rename a result file based on the old and new parameter files.
        TODO: Allow a list of suffixes
        TODO: Update Sumatra records database
        TODO: Match any extension; if multiple are present, ask something.
        Parameters
        ----------
        src: str
            Original parameter file
        dst: str
            New parameter file
        link: bool (default: True)
            If True, add a symbolic link from the old file name to the new.
            This avoids invalidating everything linking to the old filename.
        """
        if ext != "" and ext[0] != ".":
            ext = "." + ext
        old_params = parameters.ParameterSet(src)
        new_params = parameters.ParameterSet(dst)
        old_filename = core.RunMgr._get_filename(old_params, suffix) + ext
        new_filename = core.RunMgr._get_filename(new_params, suffix) + ext
        old_filename = os.path.join(datadir, old_filename)
        new_filename = os.path.join(datadir, new_filename)

        if not os.path.exists(old_filename):
            raise FileNotFoundError("The file '{}' is not in the current directory."
                                    .format(old_filename))
        if os.path.exists(new_filename):
            print("The target filename '{}' already exists. Skipping the"
                  "renaming of '{}'.".format(new_filename, old_filename))
        else:
            os.rename(old_filename, new_filename)
            print("Renamed {} to {}.".format(old_filename, new_filename))
        if link:
            # Allowing the link to be created even if rename failed allows to
            # rerun to add missing links
            # FIXME: Currently when rerunning the script dies on missing file
            #   before getting here
            os.symlink(os.path.basename(new_filename), old_filename)
            print("Added symbolic link from old file to new one")

    cli.add_command(rename)

    @click.command()
    @click.option('--datadir', default="data")
    @click.option('--labeldir', default="run_dump")
    @click.option('--link/--no-link', default=True)
    def archive(datadir, labeldir, link):
        """
        Walk through the data directory and move files under timestamp directories
        (generated by Sumatra to differentiate calculations) to the matching
        'label-free' directory.
        E.g. if a file has the path 'data/run_dump/20170908-120245/inputs/generated_data.dat',
        it is moved to 'data/inputs/generated_data.dat'. In general,
        '[datadir]/[labeldir]/[timestamp]/[dir1]/.../[dirn]/[filename]' -> '[datadir]/[dir1]/.../[dirn]/[filename]'

        By default, links are created from the old location to the new one. This can be
        disabled by passing the '--no-link' option.

        TODO: Get datadir from Sumatra
        TODO: Something sane when the target file already exists
        """

        lbl_pattern = '[0-9]{8}-[0-9]{6}'

        for dirname in os.listdir(os.path.join(datadir, labeldir)):
            if re.fullmatch(lbl_pattern, dirname):
                # This is a label directory
                path = os.path.join(datadir, labeldir, dirname)
                ## Loop over every file it contains
                for dirpath, dirnames, filenames in os.walk(path):
                    for filename in filenames:

                        ## Assemble the current path
                        old_path = os.path.join(dirpath, filename)
                        if os.path.islink(old_path):
                            # Don't move symbolic links - they point to files that have already been moved
                            continue

                        ## Store the new (archived) path for this file
                        split_path = old_path.split('/')
                        if split_path[0] == '':
                            # Fix for absolute paths
                            split_path[0] = '/'

                        if labeldir == "":
                            # Since the label directory is immediately after
                            # datadir, we can get its index by seeing how many
                            # directories deep datadir is.
                            timestamp_idx = len(datadir.split('/'))
                            dump_idx = None
                        else:
                            # There's a dump directory to remove as well
                            dump_idx = len(datadir.split('/'))
                            timestamp_idx = dump_idx + len(labeldir.split('/'))
                        assert(re.fullmatch(lbl_pattern, split_path[timestamp_idx]))
                            # Ensure that we really are removing a timestamp directory
                        del split_path[timestamp_idx]
                        if dump_idx is not None:
                            del split_path[dump_idx:timestamp_idx]
                        new_path = os.path.join(*split_path)

                        ## Move the filename and create the link
                        if os.path.exists(new_path):
                            print("File '{}' already exists. It was left in the labeled directory."
                                  .format(new_path))
                        else:
                            os.rename(old_path, new_path)
                            if link:
                                rel_new_path = os.path.relpath(new_path, os.path.dirname(old_path))
                                os.symlink(rel_new_path, old_path)

    cli.add_command(archive)


    if __name__ == "__main__":
        cli()
